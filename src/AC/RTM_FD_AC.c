/*------------------------------------------------------------------------
 *  Acoustic FDFD Reverse Time Migration
 *
 *  D. Koehn
 *  Kiel, 19.08.2016
 *  ----------------------------------------------------------------------*/

#include "fd.h"

void RTM_FD_AC(char *fileinp1){

	/* declaration of global variables */
        extern int NX, NY, NSHOT1, NSHOT2, GRAD_METHOD, NLBFGS, MYID, ITERMAX, LINESEARCH;
	extern int NXG, NYG, NXNY, LOG, N_STREAMER, INFO, INVMAT, READMOD, NSHOTS;
	extern int NX0, NY0, NPML, READ_REC, FSSHIFT;
	extern int NPROCFREQ, NPROCSHOT, NP, MYID_SHOT, NSHOT1, NSHOT2, COLOR, NF;
        extern char MISFIT_LOG_FILE[STRING_SIZE], LOG_FILE[STRING_SIZE];
        extern float PRO, A0_PML, FC_high, FC_low;

	extern FILE *FP;
    
        /* declaration of local variables */
        int i, j;
        char ext[10];
	int ntr, nshots;

	/*vector for abort criterion*/
	float * L2_hist=NULL;

	/* variables for workflow */
	int nstage, stagemax, iter, iter_true;
        
        /* variables for step-length estimation */
        float eps_scale, L2, *L2t, diff;

        FILE *FP_stage, *FPL2;

	/* open log-file (each PE is using different file) */
	/*	fp=stdout; */
	sprintf(ext,".%i",MYID);  
	strcat(LOG_FILE,ext);

	if ((MYID==0) && (LOG==1)) FP=stdout;
	else FP=fopen(LOG_FILE,"w");
	fprintf(FP," This is the log-file generated by PE %d \n\n",MYID);

	/* output of parameters to log-file or stdout */
	if (MYID==0) write_par(FP);

	/* store old NX and NY values */
	NX0 = NX;
        NY0 = NY;

	/* add external PML layers */
	NX += 2 * NPML;
	NY += NPML + FSSHIFT;

	NXG = NX;
	NYG = NY;

	/* size of impedance matrix */
	NXNY = NX * NY;

	/* Calculate number of non-zero elements in impedance matrix */
	calc_nonzero();

	/* define data structures for acoustic problem */
	struct waveAC;
	struct matAC;
	struct PML_AC;
	struct acq;

	/* allocate memory for acoustic forward problem */
	alloc_waveAC(&waveAC,&PML_AC);
	alloc_matAC(&matAC);

	/* If INVMAT!=0 deactivate unnecessary output */
	INFO=0;

	/* If INVMAT==0 allow unnecessary output */
	if((INVMAT==0)||(INVMAT==2)){
	   INFO=1;
	}

	/*if (MYID == 0) info_mem(stdout,NLBFGS_vec,ntr);*/

	/* Reading source positions from SOURCE_FILE */ 	
	acq.srcpos=sources(&nshots);

	/* read receiver positions from receiver files for each shot */
	if(READ_REC==0){

	    acq.recpos=receiver(FP, &ntr, 1);

	    fwiAC.presr = vector(1,ntr);
 	    fwiAC.presi = vector(1,ntr);		                         

	}

	/* read/create P-wave velocity */
	if (READMOD){
	    readmod(&matAC); 
	}else{
	    model(matAC.vp);
	}

	/* read parameters from workflow-file (stdin) */
	FP=fopen(fileinp1,"r");
	if(FP==NULL) {
		if (MYID == 0){
			printf("\n==================================================================\n");
			printf(" Cannot open GERMAINE workflow input file %s \n",fileinp1);
			printf("\n==================================================================\n\n");
			err(" --- ");
		}
	}

	/* estimate number of lines in FWI-workflow */
	i=0;
	stagemax=0;
	while ((i=fgetc(FP)) != EOF)
	if (i=='\n') ++stagemax;
	rewind(FP);
	stagemax--;
	fclose(FP);

	/* In case of RTM use only first line of workflow file and ignore the other */
	stagemax=1;

	/* define data structures and allocate memory for acoustic FWI problem */
	struct fwiAC;
	alloc_fwiAC(&fwiAC,ntr);

	/* initiate vp, ivp2, k2 */
	init_mat_AC(&waveAC,&matAC);

	/* Begin of FWI inversion workflow */
	for(nstage=1;nstage<=stagemax;nstage++){

		/* read workflow input file *.inp */
		FP_stage=fopen(fileinp1,"r");
		read_par_inv(FP_stage,nstage,stagemax);

		/* estimate frequency sample interval */
		waveAC.dfreq = (FC_high-FC_low) / (NF-1);

		/* estimate frequencies for current FWI stage */
		waveAC.stage_freq = vector(1,NF);
		waveAC.stage_freq[1] = FC_low;

		for(i=2;i<=NF;i++){
	    		waveAC.stage_freq[i] = waveAC.stage_freq[i-1] + waveAC.dfreq; 
		} 		

		/* split MPI communicator for shot parallelization */
		COLOR = MYID / NPROCFREQ;

		MPI_Comm shot_comm;
		MPI_Comm_split(MPI_COMM_WORLD, COLOR, MYID, &shot_comm);		

		/* esimtate communicator size for shot_comm and number of colors (NPROCSHOT) */
		MPI_Comm_rank(shot_comm, &MYID_SHOT);
		NPROCSHOT = NP / NPROCFREQ;

		/* Initiate MPI shot parallelization */
		init_MPIshot(nshots);

		/* Initiate MPI frequency parallelization */		
		init_MPIfreq();

                /* allocate memory for FD data */
		if(READ_REC==0){
 	           alloc_seis_AC(&waveAC,ntr,nshots);
		   alloc_seis_fwi_AC(&fwiAC,ntr,nshots);
		   read_seis_AC(&fwiAC,nshots,ntr,nstage);			                         
	        }

		NSHOTS = nshots;

		if (MYID==0){
		   printf("\n\n\n ------------------------------------------------------------------\n");
		   printf("\n\n\n                2D Acoustic Reverse Time Migration                 \n");
		   printf("\n\n\n ------------------------------------------------------------------\n");
		}

		/* FD Reverse Time Migration (RTM)  */
		/* -------------------------------- */

	        /* calculate Vp image */
		L2 = grad_obj_AC(&fwiAC,&waveAC,&PML_AC,&matAC,acq.srcpos,nshots,acq.recpos,ntr,iter,nstage);			

		/* free shot_comm, stage_freq and FD data arrays */
		MPI_Comm_free(&shot_comm);
		free_vector(waveAC.stage_freq,1,NF);

		if(READ_REC==0){

                   free_vector(waveAC.precr,1,ntr*NF*nshots);
            	   free_vector(waveAC.preci,1,ntr*NF*nshots);

            	   free_vector(fwiAC.pobsr,1,ntr*NF*nshots);
                   free_vector(fwiAC.pobsi,1,ntr*NF*nshots);

		}

	} /* End of RTM-workflow loop */

	/* apply smoothing and taper functions to gradient */
	precond(fwiAC.grad);

        /* write RTM result */
        RTM_AC_out(fwiAC.grad);        

        /* memory deallocation */

        /* free memory for gradient */
        free_matrix(fwiAC.lam,1,NY,1,NX);
        free_matrix(fwiAC.grad,1,NY,1,NX);
        free_matrix(fwiAC.gradm,1,NY,1,NX);
   	free_matrix(fwiAC.Hgrad,1,NY,1,NX);
	free_matrix(fwiAC.vp_old,1,NY,1,NX);
	free_matrix(fwiAC.forwardr,1,NY,1,NX);
	free_matrix(fwiAC.forwardi,1,NY,1,NX);

	/* deallocation of memory */
	free_matrix(matAC.vp,1,NY,1,NX);
	free_matrix(matAC.ivp2,1,NY,1,NX);
	free_matrix(matAC.k2,1,NY,1,NX);

	/* free memory for source positions */
	free_matrix(acq.srcpos,1,8,1,nshots);

	if(READ_REC==0){
	    free_imatrix(acq.recpos,1,3,1,ntr);
	}
        	    
}
